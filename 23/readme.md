# 并发（二）GPM调度机制

## 串行工作机制

串行执行：单进程工作，必须先执行完上一个程序，再执行下一个程序，除非暂停当前程序，不然下一个程序就无法进行
缺点：不易用，且对阻塞时对CPU性能造成了极大的浪费

## 多进程并发模式

并发模式：不同的线程运行在不同的CPU核心上。
线程分类：
    + 内核态：由CPU调度真正意义上的线程
    + 用户态：实际上用户操作的是协程，协程的切换由写成调度器切换，相较于线程更快速和轻量

GO语言的高并发：将多个协程绑定在多个线程中分配给不同的CPU核心运行，并发 + 并行

## GPM任务调度模型

![调度模型](https://juejin.cn/book/7039174186522116131/section/7083899145257386020)

1. 程序启动自动根据CPU核心数设置线程最大数量
2. 协程队列满了以后全局队列暂存所有等待的协程任务
3. 发起协程任务先添加到**协程队列中**，每个协程队列最大任务数为256，协程队列数量可以指定
4. 当一个协程队列为空后，从全局或者其他协程队列中，分一般到当前协程队列中继续并行执行


## 动态调整系统资源

获取CPU架构和核心数量

```go
// 获取运行当前程序的操作系统
fmt.Println(runtime.GOOS)
// 获取运行当前程序的CPU架构
fmt.Println(runtime.GOARCH)
// 获取运行当前程序的CPU核心数量
fmt.Println(runtime.NumCPU())

if runtime.NumCPU() > 2 {
   // 设置GO最大的线程数
   runtime.GOMAXPROCS(runtime.NumCPU() / 2)
}
// 获取当前程序可用的CPU核心数
fmt.Println(runtime.GOMAXPROCS(0))
```

## 如何让主线程让出资源

1. 使用`sync`中的`sync.Wait`让主线程等待
2. 使用`runtime.Gosched`来等待协程执行

## 终止当前协程

使用`runtime.Goexit()`直接推出当前协程


